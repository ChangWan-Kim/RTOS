# Learing-RTOS-with-STM32
!Learing RTOS with STM32
- https://github.com/d-h-k/Learing-RTOS-with-STM32.git
- RTOS교육 강의 노트 written by DHKim
 # 
 # Day1
 ## RTOS 소개 및 개발환경 구축
  - 사용보드 STM32L475 IOT discovery kit
  - ARM 소개 및 STM32 시리즈 소개 해당 mcu는 80hmz로 동작
  - printf 사용법 : 표준입출력 리다이렉션 기능을 활용해서 printf 함수 사용함
    - 표준입출력 리다이렉션
       ```

       ```
    - freertos의 printf 는 사용하지 않음 
  - RTOS 분류 : 세상에 존재하는 많은 OS 들을 두가지로 나누어본다면 범용OS/특수목적OS 로 나눌수 있음
    - 범용OS : 맥 리눅스 윈도우 안드로이드 ios 블랙베리 훙멍 등등... 많은 디바이스들을 많은 사용자가 쓸수 있게 제작한 OS
    - 특수목적OS : RTOS류(FreeRTOS, Vxworks 등등..)가 대표적으로 특정한 임무(화성탐사, 모터제어 등등..)를 할수 있게끔 제작된 OS
  - RTOS의 가장 큰 특징은 단일 프로세스임. 예를들어 윈도우에서는 멀티 프로세스가 동작하는데에 비해 RTOS에서는 단일 프로세스에 여러가지 태스크(쓰래드의 개념)가 동작함
  - RTOS의 핵심적인 개념은 스케쥴러가 선점형이라는것, 비선점형은 라운드로빈을 찾아보기 바람
  - 여기서 잠깐 정리해야 할 개념
    - 프로세서
    - 프로세스
    - 태스크
    - CPU의 코어
    - 프로세스와 쓰래드의 차이(부팅된 OS에서 RAM에 올라와있는 프로그램의 영역)
    - 32bit cpu 및 os 시스템의 메모리공간 크기는
  - CMSIS란? ARM에서 제공하는 코어 IP간에 공통적인 규약
  - FreeRTOS는 오픈소스였는데 아마존이 인수한 이후 아마존 AWS 붙이는 용도로 돌아감
  - RTOS는 시분할 시스템 TDD이며 시간은 위에서 말한 80MHz 클럭에서 시간을 측정함 STM32에서는 이를 Time base Source 라고 칭하며 Tick 이라는 이름으로 존재
  - Tick이란 ARM사에서 core IP를 제공할때 모는 코어에 공통적으로 들어가있는 하드웨어적 타이머임.
  - 이제 실무를 위해 RTOS를 어떻게 돌릴지 알려주마!
    - CubeMX설치 (5.)버전
    - TrueStudio For STM32 설치(9.3)
    - L4용 CubeMX Software 다운로드
  - RTOS는 CMSISv1 버전을 사용
  - 주어진 보드에 MCU공부는 당연히 필요함 -> 알아서들 열심히 하기를
  - Timer 6번을 사용 RTOS는 Timer 6번을 사용함
  - 왜 타이머6번을 사용하는지는 L475 코어 메뉴얼의 fig368 및 데이터시트를 참고하시기 바람
  - RTOS 로 APP을 짜면 호환같은거 바라지마라(예를들어 TI에서 돌던걸 한다거나..) -> 정 원한다면 하나의 추가 레이어를 만들어야 할듯
  - 더욱 자세한 이해를 위해 리눅스 커널이나 시스템프로그래밍 앱을 만든 경험이 도움됨 (멀티스레드, 멀티프로세스)
 ## RTOS실습하기 앞서 실무적으로 알아야할 내용
  - 첫번째 개념 Task : 상태 천이를 이해해야 함 프로그래밍 방법론에서 나오는 상태머신
  - RTOS로 코드를 짜는 순간부터 프로그래머가 아닌 OS가 모든 동작을 관할하게 되므로, OS에 대한 이해와 보드에 대한 이해가 필수적임
  - Running 은 Ready 인 타스크들을 상태로 os가 알아서 만들어줌
  - 프로그래머는 Ready 상태를 만들수 있지 Running 상태를 만들 수는 없음
  - suspended 상태인 프로세스를 러닝 상태가 아닌 레디 상태로만 만들수 있다는게 핵심 중요!!! 두번말하는건 그만큼 중요하다구요!! 이유가 있다는겁니다!
  - Ready상태에서 Runing 으로 동작하는것의 주체는 RTOS가! 더 자세히는 커널이 더 자세히는 스케쥴러가 주체가 됨
  - Block은 사용자가 태스크를 정지시키고자 할때, 주체가 프로그래머!! 수동적
  - Suspeneded 는 주체가 스케쥴러가!! 알아서! 능동적
 ## 예제 1번
  - 선점형 스케쥴려라 0xffffff = 128 이므로 task1만 계속돌고 task2는 안도는거 확인
  - 알아야 할 것들 정리 및 개념 보강
    - 메모리의 3대 영역은 힙, 스텍, 데이터
    - 이거는 버그 비슷한건데 main.c 에서 freertos 커널 호출전 printf를 꼭 한번 호출해야 프린트에프가 동작함
    - for문에 걸려 busy wait 지금은 wait이 없음
  - 예제 1번은 우선순위가 높은 태스크가 계속 스케쥴러를 잡고있음 그래서 선점형 스케쥴링
  - 질문사항
    - 어떨때 RTOS를 써야 유리한지 : 비동기적일때, 통신이 많이 오고갈때, 특히 TCPIP 기능 사용할떄(이더넷 와이파이 http등..)
 # 
 # Day2
 - 도착 7시 30분
 - vTaskDelayUntil
 - 레이스 컨디션!
 - 참조링크 
  ``` 
    https://it4all.tistory.com/34
    https://www.freertos.org/FreeRTOS-Plus/BSP_Solutions/ST/STM32Cube.html
  ```
 - 나 오기전에 2~8예제 돌린듯 
 ## 예제 9번 태스크 삭제
 - 스케쥴려 의 스케쥴링 알고리즘 더 공부하기
 - 피어리딕 시킬려고 딱 잡았죠 함수가 없어
  - 스케쥴려는 함수가 없는줄 알고 점프! ->> 시스템 다운! 사망
 - 결론: 어떤 테스크를 없애고 싶으면 델리트 명령어를 확실히 지워줘야 됭 그래야 스케줄러가 확실히 빼줌
 - Free RTOS는 조심해야된단다 : 피리어딕 
 - 조심할부분 Hook 이나 Idel TASK 함수를 어떻게 쓰라 알려드리는거가 아닌 개념을 이해 
 - 큐 : 선입선출 
 - 블럭 :  이벤트를 기다리는 테스크의 상태
 - 스케쥴러 - 큐 버퍼 언더런시 블락 기다리는 데이터 : 이벤트를 기다리기 
 - RTOS의 이벤트는 인터럽트 같은것
 - 가장 기본적인 Delay 또한 이벤트
 - 큐가 들어오면 즉각반응해야 한다 ->> 우선순위 최상으로
 ## 예제 10번
 ## 예제 11번 : pv파라미터의 자리에 : &xStructsToSend[0]
  - >> 강사는 질문에 무성의 방어만 하지말고 칭찬앤 칭찬 달려 더 궁금하도록!
 ## 예제12번 큐셋 : 다중에 큐에서 데이터를 꼭 한군데서만 읽어야할때 씀 권장하지 않음 효율도 좋지않음
 - 데이터 스트럭쳐의 흐름 테스크 갯수 등등 어플리케이션 구조를 꼭 잡아야되 (이산이 아닌가벼~)
생각하시고 하셔야합니다
 - Mailbox = 길이가 1 인 큐 :: 하나의 데이터를 안전하게 보내는 
 - overwrite -> 엎어쓰기 
 - Peek -> 읽지만 데이터를 지우지 않는다
 - port max delay : 
 